Profiling

Look into sprof, gprof, profil

# But before we do that, holy stack frames, batman!

I put some prints in zn.py to show what was happening.  
This is the number of calls for each nobj.

About the output:  
Hmmm..
209 / 19 ~ 10
598 / 209 ~ 3
288 / 598 ~ 0.5

This is pretty consistent, give or take a little, as we go.  What does it mean?
Well, level 1 is the 2d silhouettes.  Does it make sense that we do *ten* of
those calls for each point?  Wait, look at the input file.  There are really
50 points.  So that's pretty good.  For a random set, we get away without doing
an iteration for about 60% of the points.

Now, let's consider the calls at 0:  those are a total waste and we could cut
them right out.

input front number hv
{0: 288, 1: 598, 2: 209, 3: 19}
461 steps
ran.50pts.3d.20 1 420.92
... more snipped ...

Here's if we just cut out those superfluous calls.
input front number hv
{1: 598, 2: 209, 3: 19}
461 steps
ran.50pts.3d.20 1 420.92
... more snipped ...

So we're saving a lot of calls.  Let's look at those numbers again.  For this
particular set, we only need to do 19 steps.  Note also that we're confounding
the two ways we recurse.  We really need to iterate as we step the nadir.
Although let's not get our hopes up that this would reduce the run time --- it
didn't help at all for hyppy.

So this subjectively seems faster.
input front number hv
{1: 336, 2: 54, 3: 1}
ran.50pts.3d.20 1 420.92
{1: 340, 2: 54, 3: 1}
ran.50pts.3d.20 2 314.96
{1: 344, 2: 54, 3: 1}
ran.50pts.3d.20 3 663.07
{1: 324, 2: 51, 3: 1}
... more snipped ...

And now we have really isolated what's going on.  Furthermore, we can now get
rid of the calls at depth one because that's just the value of the one
dimension.
input front number hv
{2: 54, 3: 1}
ran.50pts.3d.20 1 420.92
{2: 54, 3: 1}
ran.50pts.3d.20 2 314.96
{2: 54, 3: 1}
ran.50pts.3d.20 3 663.07

Now that's way fewer calls, and way less heap allocation!

How's that do for time, if we take out the bookkeeping?
$ time python metricsystem.py -M -s "#" --ZN ran.50pts.3d.20 
input front number hv
... snip correct output ...
real    0m1.653s
user    0m1.643s
sys     0m0.007s

For comparison, here's the old version:
$ time python metricsystem.py -M -s "#" --ZN ran.50pts.3d.20  
input front number hv
... snip correct output ...
real    0m2.035s
user    0m2.020s
sys     0m0.007s

And here's with the box subtraction.  Note the right answers!
Ah, but we've lost the iterations.

input front number hv
{2: 54, 3: 1}
ran.50pts.3d.20 1 420.92
{2: 54, 3: 1}
ran.50pts.3d.20 2 314.96
{2: 54, 3: 1}
ran.50pts.3d.20 3 663.07
{2: 51, 3: 1}
ran.50pts.3d.20 4 447.78
{2: 54, 3: 1}
ran.50pts.3d.20 5 577.29
{2: 51, 3: 1}
ran.50pts.3d.20 6 558.17
... more snipped ...

Here are the reference values, from wfg2reference:

hv(1) = 420.9157937854
hv(2) = 314.9607306193
hv(3) = 663.0700463699
hv(4) = 447.7808989788
hv(5) = 577.2869694112
hv(6) = 558.1743910434
hv(7) = 376.1782035395
hv(8) = 145.6237883536
hv(9) = 415.1374490645
hv(10) = 286.6852582773
hv(11) = 304.2986767407
hv(12) = 492.3748651029
hv(13) = 217.2465220667
hv(14) = 603.6544059577
hv(15) = 702.1218570090
hv(16) = 509.5372768990
hv(17) = 567.8103779492
hv(18) = 249.7652859076
hv(19) = 579.9724835200
hv(20) = 379.7277340091

Anyway, note that we didn't get any fewer recursions.  So something's wrong ---
we should have had fewer steps and thus fewer recursions.
