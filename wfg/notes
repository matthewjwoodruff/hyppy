Profiling

Look into sprof, gprof, profil

# But before we do that, holy stack frames, batman!

I put some prints in zn.py to show what was happening.  
This is the number of calls for each nobj.

About the output:  
Hmmm..
209 / 19 ~ 10
598 / 209 ~ 3
288 / 598 ~ 0.5

This is pretty consistent, give or take a little, as we go.  What does it mean?
Well, level 1 is the 2d silhouettes.  Does it make sense that we do *ten* of
those calls for each point?  Wait, look at the input file.  There are really
50 points.  So that's pretty good.  For a random set, we get away without doing
an iteration for about 60% of the points.

Now, let's consider the calls at 0:  those are a total waste and we could cut
them right out.

input front number hv
{0: 288, 1: 598, 2: 209, 3: 19}
461 steps
ran.50pts.3d.20 1 420.92
... more snipped ...

Here's if we just cut out those superfluous calls.
input front number hv
{1: 598, 2: 209, 3: 19}
461 steps
ran.50pts.3d.20 1 420.92
... more snipped ...

So we're saving a lot of calls.  Let's look at those numbers again.  For this
particular set, we only need to do 19 steps.  Note also that we're confounding
the two ways we recurse.  We really need to iterate as we step the nadir.
Although let's not get our hopes up that this would reduce the run time --- it
didn't help at all for hyppy.

So this subjectively seems faster.
input front number hv
{1: 336, 2: 54, 3: 1}
ran.50pts.3d.20 1 420.92
{1: 340, 2: 54, 3: 1}
ran.50pts.3d.20 2 314.96
{1: 344, 2: 54, 3: 1}
ran.50pts.3d.20 3 663.07
{1: 324, 2: 51, 3: 1}
... more snipped ...

And now we have really isolated what's going on.  Furthermore, we can now get
rid of the calls at depth one because that's just the value of the one
dimension.
input front number hv
{2: 54, 3: 1}
ran.50pts.3d.20 1 420.92
{2: 54, 3: 1}
ran.50pts.3d.20 2 314.96
{2: 54, 3: 1}
ran.50pts.3d.20 3 663.07

Now that's way fewer calls, and way less heap allocation!

How's that do for time, if we take out the bookkeeping?
$ time python metricsystem.py -M -s "#" --ZN ran.50pts.3d.20 
input front number hv
... snip correct output ...
real    0m1.653s
user    0m1.643s
sys     0m0.007s

For comparison, here's the old version:
$ time python metricsystem.py -M -s "#" --ZN ran.50pts.3d.20  
input front number hv
... snip correct output ...
real    0m2.035s
user    0m2.020s
sys     0m0.007s

And here's with the box subtraction.  Note the right answers!
Ah, but we've lost the iterations.

input front number hv
{2: 54, 3: 1}
ran.50pts.3d.20 1 420.92
{2: 54, 3: 1}
ran.50pts.3d.20 2 314.96
{2: 54, 3: 1}
ran.50pts.3d.20 3 663.07
{2: 51, 3: 1}
ran.50pts.3d.20 4 447.78
{2: 54, 3: 1}
ran.50pts.3d.20 5 577.29
{2: 51, 3: 1}
ran.50pts.3d.20 6 558.17
... more snipped ...

Here are the reference values, from wfg2reference:

hv(1) = 420.9157937854
hv(2) = 314.9607306193
hv(3) = 663.0700463699
hv(4) = 447.7808989788
hv(5) = 577.2869694112
hv(6) = 558.1743910434
hv(7) = 376.1782035395
hv(8) = 145.6237883536
hv(9) = 415.1374490645
hv(10) = 286.6852582773
hv(11) = 304.2986767407
hv(12) = 492.3748651029
hv(13) = 217.2465220667
hv(14) = 603.6544059577
hv(15) = 702.1218570090
hv(16) = 509.5372768990
hv(17) = 567.8103779492
hv(18) = 249.7652859076
hv(19) = 579.9724835200
hv(20) = 379.7277340091

Anyway, note that we didn't get any fewer recursions.  So something's
wrong --- we should have had fewer steps and thus fewer recursions.

First step is to see whether we're doing it at all.  Which we're not,
so there's the problem.  Ah ha, I found the problem.  An if that
should have been an elif.  But I still get the wrong numbers.

And here's why.  The point I'm looking for must be in the silhouette,
but it must also be a nadir point for the axis we're working on.  Is
even that enough to be correct?  So the idea is that no other point
overlaps its hypervolume because it's the nadir point for that axis.

Hmmm.  Even with that more restrictive condition, I'm still way
under-computing hypervolume:

{2: 27, 3: 1}
ran.50pts.3d.20 1 323.49
{2: 24, 3: 1}
ran.50pts.3d.20 2 187.44
{2: 24, 3: 1}
ran.50pts.3d.20 3 617.11
{2: 27, 3: 1}
ran.50pts.3d.20 4 294.83

OK, I'm close to giving up.  Check this out, I instrumated wfg2.c, and it's
just about infinitely better:

python metricsystem.py random/13d/ran.8pts.13d.20 -s"#" -M

input front number hv
0: 1,  1: 7,  2: 19,  3: 23,  4: 15,  5: 6,  6: 1,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 1 8.85e+09
0: 1,  1: 7,  2: 21,  3: 34,  4: 31,  5: 15,  6: 3,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 2 8.3521e+10
0: 1,  1: 7,  2: 21,  3: 33,  4: 26,  5: 8,  6: 0,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 3 3.8981e+09
0: 1,  1: 7,  2: 21,  3: 35,  4: 32,  5: 15,  6: 3,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 4 1.7749e+09
0: 1,  1: 7,  2: 21,  3: 33,  4: 26,  5: 9,  6: 1,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 5 2.4722e+09
0: 1,  1: 7,  2: 21,  3: 35,  4: 35,  5: 21,  6: 7,  7: 1,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 6 1.0664e+10
0: 1,  1: 7,  2: 21,  3: 30,  4: 19,  5: 4,  6: 0,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 7 3.263e+08
0: 1,  1: 7,  2: 21,  3: 32,  4: 23,  5: 8,  6: 1,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 8 4.6339e+08
0: 1,  1: 7,  2: 21,  3: 31,  4: 23,  5: 8,  6: 1,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 9 5.1916e+09
0: 1,  1: 7,  2: 21,  3: 29,  4: 20,  5: 7,  6: 1,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 10 1.089e+09
0: 1,  1: 7,  2: 21,  3: 31,  4: 25,  5: 11,  6: 2,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 11 8.9495e+08
0: 1,  1: 7,  2: 21,  3: 35,  4: 35,  5: 20,  6: 5,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 12 9.2745e+09
0: 1,  1: 7,  2: 21,  3: 35,  4: 35,  5: 21,  6: 7,  7: 1,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 13 4.6782e+09
0: 1,  1: 7,  2: 21,  3: 35,  4: 35,  5: 21,  6: 7,  7: 1,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 14 9.1065e+09
0: 1,  1: 7,  2: 19,  3: 26,  4: 17,  5: 4,  6: 0,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 15 1.8864e+10
0: 1,  1: 7,  2: 21,  3: 34,  4: 31,  5: 15,  6: 3,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 16 1.6654e+10
0: 1,  1: 7,  2: 21,  3: 34,  4: 31,  5: 14,  6: 2,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 17 1.6496e+10
0: 1,  1: 7,  2: 17,  3: 14,  4: 4,  5: 0,  6: 0,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 18 4.1097e+10
0: 1,  1: 7,  2: 20,  3: 29,  4: 22,  5: 8,  6: 1,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 19 6.8186e+09
0: 1,  1: 7,  2: 21,  3: 34,  4: 27,  5: 9,  6: 1,  7: 0,  8: 0,  9: 0,  10: 0,  11: 0,  12: 0,  
random/13d/ran.8pts.13d.20 20 1.1767e+09

[mwoodruff@DecisionVisPC9 wfg]$ python metricsystem.py random/13d/ran.8pts.13d.20 -s"#" -M --ZN
input front number hv
{2: 13259, 3: 10803, 4: 7873, 5: 4936, 6: 2860, 7: 1529, 8: 747, 9: 324, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 1 8.85e+09
{2: 26749, 3: 19118, 4: 11424, 5: 6435, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 2 8.3521e+10
{2: 26523, 3: 17673, 4: 10972, 5: 6361, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 3 3.8981e+09
{2: 26606, 3: 18282, 4: 11280, 5: 6412, 6: 3430, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 4 1.7749e+09
{2: 29950, 3: 19237, 4: 11440, 5: 6435, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 5 2.4722e+09
{2: 26765, 3: 18516, 4: 11376, 5: 6433, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 6 1.0664e+10
{2: 21112, 3: 14801, 4: 9854, 5: 6172, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 7 3.263e+08
{2: 29392, 3: 19004, 4: 11405, 5: 6431, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 8 4.6339e+08
{2: 19405, 3: 13854, 4: 8947, 5: 5452, 6: 3114, 7: 1649, 8: 784, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 9 5.1916e+09
{2: 24746, 3: 17605, 4: 11220, 5: 6435, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 10 1.089e+09
{2: 30416, 3: 19307, 4: 11440, 5: 6435, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 11 8.9495e+08
{2: 28332, 3: 18832, 4: 11337, 5: 6424, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 12 9.2745e+09
{2: 23340, 3: 16880, 4: 10726, 5: 6294, 6: 3407, 7: 1714, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 13 4.6782e+09
{2: 20716, 3: 14962, 4: 9713, 5: 5789, 6: 3250, 7: 1686, 8: 790, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 14 9.1065e+09
{2: 11173, 3: 8987, 4: 6645, 5: 4516, 6: 2846, 7: 1596, 8: 779, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 15 1.8864e+10
{2: 25624, 3: 17916, 4: 11174, 5: 6409, 6: 3430, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 16 1.6654e+10
{2: 28714, 3: 18553, 4: 11165, 5: 6373, 6: 3425, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 17 1.6496e+10
{2: 27094, 3: 18603, 4: 11235, 5: 6404, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 18 4.1097e+10
{2: 17017, 3: 12339, 4: 8295, 5: 5267, 6: 3116, 7: 1674, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 19 6.8186e+09
{2: 26134, 3: 17573, 4: 10956, 5: 6372, 6: 3432, 7: 1716, 8: 792, 9: 330, 10: 120, 11: 36, 12: 8, 13: 1}
random/13d/ran.8pts.13d.20 20 1.1767e+09

Note that the orders here are reversed, but the first few are pretty predictable.
I go
1, 8, 36, 120, and up and up...
Where wfg goes
1, 7, 21, and then it turns around...

I had another thought, but it's basically a new algorithm at this point.  Not
that that's bad :)

The new idea is that we can do a fully ranked Pareto sort and work from the
most dominated to the least dominated, one dimension down.  Most dominated
should, not uncoincidentally, give us the stuff that we have to subtract from
all of the other fronts.  So we can compute HV one front at a time and then
discard the front.  This requires only that at the top level we've got a
Pareto-sorted set in the first place.
